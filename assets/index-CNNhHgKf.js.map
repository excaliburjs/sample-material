{"version":3,"file":"index-CNNhHgKf.js","sources":["../../src/blackhole/perlin.png?url","../../src/blackhole/fractal.png?url","../../src/blackhole/blackhole.ts"],"sourcesContent":["export default \"__VITE_ASSET__DrdI2nGW__\"","export default \"__VITE_ASSET__Trav48Sv__\"","\nimport { Actor, Color, DisplayMode, Engine, ImageSource, Loader } from \"excalibur\";\nimport noise1 from \"./perlin.png?url\";\nimport noise2 from \"./fractal.png?url\";\nimport { glsl } from \"../glsl\";\n\nconst blackHoleFrag = glsl`#version 300 es\nprecision highp float;\n\nin vec2 v_uv;\nout vec4 fragColor;\nuniform vec2 u_resolution;\nuniform float u_time_ms;\nuniform bool U_highlighted;\nuniform sampler2D U_noise1;\nuniform sampler2D U_noise2; \n\nfloat u_time = 0.; \nconst float RETICULATION = 3.;  // strenght of dust texture\nconst float NB_ARMS = 5.;       // number of arms\nconst float COMPR = .1;         // compression in arms\nconst float SPEED = .2;\nconst float GALAXY_R = 1./2.;\nconst float BULB_R = 1./2.5;\nconst vec3 GALAXY_COL = vec3(.9,.9,1.); //(1.,.8,.5);\nconst vec3 BULB_COL   = vec3(1.,1.0,1.0);\nconst float BULB_BLACK_R = 1./4.;\nconst vec3 BULB_BLACK_COL   = vec3(0,0,0);\nconst vec3 SKY_COL    = .5*vec3(.1,.3,.5);\n#define Pi 3.1415927\n\nvec3 mod289(vec3 x)\n{\n    return x - floor(x / 289.0) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n    return x - floor(x / 289.0) * 289.0;\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - r * 0.85373472095314;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289((x * 34.0 + 1.0) * x);\n}\n\n\nfloat inverseLerp(float v, float minValue, float maxValue) {\n  return (v - minValue) / (maxValue - minValue);\n}\n\nfloat remap(float v, float inMin, float inMax, float outMin, float outMax) {\n  float lt = inverseLerp(v, inMin, inMax);\n  return mix(outMin, outMax, lt);\n}\n\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nvec4 snoise(vec3 v)\n{\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, vec3(C.y)));\n    vec3 x0 = v - i + dot(i, vec3(C.x));\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    vec3 x1 = x0 - i1 + C.x;\n    vec3 x2 = x0 - i2 + C.y;\n    vec3 x3 = x0 - 0.5;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec4 p =\n      permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0))\n                            + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n                            + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    vec4 j = p - 49.0 * floor(p / 49.0);  // mod(p,7*7)\n\n    vec4 x_ = floor(j / 7.0);\n    vec4 y_ = floor(j - 7.0 * x_); \n\n    vec4 x = (x_ * 2.0 + 0.5) / 7.0 - 1.0;\n    vec4 y = (y_ * 2.0 + 0.5) / 7.0 - 1.0;\n\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 g0 = vec3(a0.xy, h.x);\n    vec3 g1 = vec3(a0.zw, h.y);\n    vec3 g2 = vec3(a1.xy, h.z);\n    vec3 g3 = vec3(a1.zw, h.w);\n\n    // Normalize gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(g0, g0), dot(g1, g1), dot(g2, g2), dot(g3, g3)));\n    g0 *= norm.x;\n    g1 *= norm.y;\n    g2 *= norm.z;\n    g3 *= norm.w;\n\n    // Compute noise and gradient at P\n    vec4 m = max(0.5 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    vec4 m2 = m * m;\n    vec4 m3 = m2 * m;\n    vec4 m4 = m2 * m2;\n    vec3 grad =\n      -6.0 * m3.x * x0 * dot(x0, g0) + m4.x * g0 +\n      -6.0 * m3.y * x1 * dot(x1, g1) + m4.y * g1 +\n      -6.0 * m3.z * x2 * dot(x2, g2) + m4.z * g2 +\n      -6.0 * m3.w * x3 * dot(x3, g3) + m4.w * g3;\n    vec4 px = vec4(dot(x0, g0), dot(x1, g1), dot(x2, g2), dot(x3, g3));\n    return 42.0 * vec4(grad, dot(m4, px));\n}\n\n\nfloat fbm(vec3 p, int octaves, float persistence, float lacunarity, float exponentiation) {\n  float amplitude = 0.5;\n  float frequency = 1.0;\n  float total = 0.0;\n  float normalization = 0.0;\n\n  for (int i = 0; i < 1000; ++i) {\n    float noiseValue = snoise(p * frequency).w;\n    total += noiseValue * amplitude;\n    total += sin(u_time)*.015;\n    normalization += amplitude;\n    amplitude *= persistence;\n    frequency *= lacunarity;\n    if(i==(octaves-1)){\n      break;\n    }\n  }\n\n  total /= normalization;\n  total = total * 0.5 + 0.5;\n  total = pow(total, exponentiation);\n\n  return total;\n}\n\n\nfloat sdfCircle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n\nfloat map(vec3 pos) {\n  return fbm(pos, 6, 0.5, 2.0, 4.0);\n}\n\nvec3 calcNormal(vec3 pos, vec3 n) {\n  vec2 e = vec2(0.0001, 0.0);\n  return normalize(\n      n + -500.0 * vec3(\n          map(pos + e.xyy) - map(pos - e.xyy),\n          map(pos + e.yxy) - map(pos - e.yxy),\n          map(pos + e.yyx) - map(pos - e.yyx)\n      )\n  );\n}\n\n\nmat3 rotateY(float radians) {\n  float s = sin(radians);\n  float c = cos(radians);\n  return mat3(\n      c, 0.0, s,\n      0.0, 1.0, 0.0,\n      -s, 0.0, c);\n}\n\nfloat tex(vec2 uv){\n    return  texture(U_noise1,uv).r;\n}\n\n\n// --- perlin turbulent noise + rotation\nfloat noise(vec2 uv)\n{\n\tfloat v=0.;\n\tfloat a=-SPEED*u_time,co=cos(a),si=sin(a); \n\tmat2 M = mat2(co,-si,si,co);\n\tconst int L = 7;\n\tfloat s=1.;\n\tfor (int i=0; i<L; i++)\n\t{\n\t\tuv = M*uv;\n\t\tfloat b = tex(uv*s);\n\t\tv += 1./s* pow(b,RETICULATION); \n\t\ts *= 2.;\n\t}\n\t\n    return v/2.;\n}\n\nvoid main() {\n    u_time = u_time_ms / 1000.;\n    vec2 uv = (v_uv -.5) * 2.0;\n    vec3 col;\n\n    // spiral stretching with distance\n    float rho = length(uv); // polar coords\n    float ang = atan(uv.y,uv.x);\n    float shear = 2.*log(rho); // logarythmic spiral\n    float c = cos(shear);\n    float s = sin(shear);\n    mat2 R = mat2(c,-s,s,c);\n\n    // galaxy profile\n    float r; \n    r = rho/GALAXY_R; \n    float dens = exp(-r*r);\n    r = rho/BULB_R;\n    float bulb = exp(-r*r);\n    r = rho/BULB_BLACK_R; \n    float bulb_black = exp(-r*r);\n    float phase = NB_ARMS*(ang-shear);\n\n    ang = ang-COMPR*cos(phase)+SPEED*u_time;\n    uv = rho*vec2(cos(ang),sin(ang));\n    float spires = 1.+NB_ARMS*COMPR*sin(phase);\n    dens *= .7*spires;\t\n\n    // gaz texture\n    float gaz = noise(.09*1.2*R*uv);\n    float gaz_trsp = pow((1.-gaz*dens),2.);\n\t\n    // adapt stars size to display resolution\n    float ratio = 1.;\n    float stars1 = texture(U_noise2,ratio*uv+.5).r;\n    float stars2 = texture(U_noise2,ratio*uv+.5).r;\n    float stars = pow(1.-(1.-stars1)*(1.-stars2),5.);\n\n\n    // mix all\t\n    vec3 galColor = gaz_trsp*(1.7*GALAXY_COL) + 1.9*stars;\n    vec4 col_a = mix(vec4(SKY_COL,0.0),vec4(galColor,1.5), dens );\n    col_a = mix(col_a,   vec4(2.*BULB_COL,1.0),   1.05* bulb);\n\t  if(U_highlighted==false){\n        col_a = col_a * 0.6;\n    }\n\n    col_a = mix(col_a, vec4( 1.2* BULB_BLACK_COL, 1.0), 2.0*bulb_black);\n    fragColor = col_a;\n    fragColor.rgb = fragColor.rgb * fragColor.a;\n}\n`;\nconst game = new Engine({\n\twidth: 800,\n\theight: 800,\n\tdisplayMode: DisplayMode.FitScreen,\n\tsuppressPlayButton: true,\n\tbackgroundColor: Color.fromRGB(100, 60, 120)\n});\nconst imgNoise1 = new ImageSource(noise1);\nconst imgNoise2 = new ImageSource(noise2);\n\nconst loader = new Loader([\n\timgNoise1,\n\timgNoise2\n]);\n\nconst blackHole = new Actor({\n\tpos: game.screen.center,\n\twidth: 800,\n\theight: 800,\n\tcolor: Color.Transparent,\n\tz: 1\n});\nblackHole.graphics.material = game.graphicsContext.createMaterial({\n\tfragmentSource: blackHoleFrag,\n\timages: {\n\t\tU_noise1: imgNoise1,\n\t\tU_noise2: imgNoise2,\n\t}\n});\n\ngame.add(blackHole);\ngame.start(loader);\n"],"names":["noise1","noise2","blackHoleFrag","glsl","game","Engine","DisplayMode","Color","imgNoise1","ImageSource","imgNoise2","loader","Loader","blackHole","Actor"],"mappings":"sHAAA,MAAeA,EAAA,8CCAAC,EAAA,+CCMTC,EAAgBC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA4QhBC,EAAO,IAAIC,EAAO,CACvB,MAAO,IACP,OAAQ,IACR,YAAaC,EAAY,UACzB,mBAAoB,GACpB,gBAAiBC,EAAM,QAAQ,IAAK,GAAI,GAAG,CAC5C,CAAC,EACKC,EAAY,IAAIC,EAAYT,CAAM,EAClCU,EAAY,IAAID,EAAYR,CAAM,EAElCU,EAAS,IAAIC,EAAO,CACzBJ,EACAE,CACD,CAAC,EAEKG,EAAY,IAAIC,EAAM,CAC3B,IAAKV,EAAK,OAAO,OACjB,MAAO,IACP,OAAQ,IACR,MAAOG,EAAM,YACb,EAAG,CACJ,CAAC,EACDM,EAAU,SAAS,SAAWT,EAAK,gBAAgB,eAAe,CACjE,eAAgBF,EAChB,OAAQ,CACP,SAAUM,EACV,SAAUE,CAAA,CAEZ,CAAC,EAEDN,EAAK,IAAIS,CAAS,EAClBT,EAAK,MAAMO,CAAM"}