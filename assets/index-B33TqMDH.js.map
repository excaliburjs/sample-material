{"version":3,"file":"index-B33TqMDH.js","sources":["../../src/nebula/blue.png?url","../../src/nebula/nebulal.ts"],"sourcesContent":["export default \"__VITE_ASSET__D7FAMzhY__\"","import { Actor, Color, DisplayMode, Engine, ImageSource, Loader } from \"excalibur\";\nimport { glsl } from \"../glsl\";\nimport greynoise from \"./blue.png?url\";\n\nconst nebulaFrag = glsl`#version 300 es\nprecision highp float;\nuniform sampler2D u_noise;\nuniform float u_time_ms;\nfloat u_time = 0.;\nuniform vec2 u_resolution;\nin vec2 v_uv;\nout vec4 fragColor;\n\nfloat palette( in float a, in float b, in float c, in float d, in float x ) {\n    return a + b * cos(6.28318 * (c * x + d));\n}\n\n// 2D Noise from IQ\nfloat Noise2D( in vec2 x )\n{\n    ivec2 p = ivec2(floor(x));\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    ivec2 uv = p.xy;\n\n    float rgA = texelFetch( u_noise, (uv+ivec2(0,0))&255, 0 ).x;\n    float rgB = texelFetch( u_noise, (uv+ivec2(1,0))&255, 0 ).x;\n    float rgC = texelFetch( u_noise, (uv+ivec2(0,1))&255, 0 ).x;\n    float rgD = texelFetch( u_noise, (uv+ivec2(1,1))&255, 0 ).x;\n    return mix( mix( rgA, rgB, f.x ),\n                mix( rgC, rgD, f.x ), f.y );\n}\n\nfloat ComputeFBM( in vec2 pos )\n{\n    float amplitude = 0.75;\n    float sum = 0.0;\n    float maxAmp = 0.0;\n    for(int i = 0; i < 6; ++i)\n    {\n        sum += Noise2D(pos) * amplitude;\n        maxAmp += amplitude;\n        amplitude *= 0.5;\n        pos *= 2.2;\n    }\n    return sum / maxAmp;\n}\n\n// Same function but with a different, constant amount of octaves\nfloat ComputeFBMStars( in vec2 pos )\n{\n    float amplitude = 0.75;\n    float sum = 0.0;\n    float maxAmp = 0.0;\n    for(int i = 0; i < 5; ++i)\n    {\n        sum += Noise2D(pos) * amplitude;\n        maxAmp += amplitude;\n        amplitude *= 0.5;\n        pos *= 2.0;\n    }\n    return sum / maxAmp * 1.15;\n}\n\nvec3 BackgroundColor( in vec2 uv ) {\n    \n    // Sample various noises and multiply them\n    float noise1 = ComputeFBMStars(uv * 5.0);\n    float noise2 = ComputeFBMStars(uv * vec2(15.125, 25.7));\n    float noise3 = ComputeFBMStars((uv + vec2(0.5, 0.1)) * 4.0 + u_time * 0.35);\n    float starShape = noise1 * noise2 * noise3;\n    \n    // Compute star falloff - not really doing what i hoped it would, i wanted smooth falloff around each star\n    float falloffRadius = 0.2;\n    float baseThreshold = 0.6; // higher = less stars\n    \n    starShape = clamp(starShape - baseThreshold + falloffRadius, 0.0, 1.0);\n    //starShape = 0.002;\n    float weight = starShape / (2.0 * falloffRadius);\n    return weight * vec3(noise1 * 0.55, noise2 * 0.4, noise3 * 1.0) * 6.0; // artificial scale just makes the stars brighter\n}\n\n\nvoid main(  )\n{\n    u_time = u_time_ms / 1000.;\n    vec2 uv = v_uv;\n    vec2 scrPt = uv * 2.0 - 1.0;\n    vec4 finalColor;\n    \n   \n\t// Define density for some shape representing the milky way galaxy\n    \n    float milkywayShape;\n    \n    // Distort input screen pos slightly so the galaxy isnt perfectly axis aligned\n    float galaxyOffset = (cos(scrPt.x * 5.0) * sin(scrPt.x * 2.0) * 0.5 + 0.5) * 0.0;\n    \n    // Apply a slight rotation to the screen point, similar to the galaxy\n    float theta = length(scrPt) * 0.25; // Visualy tweaked until it looked natural\n    mat2 rot;\n    \n    // cache calls to sin/cos(theta)\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n    \n    rot[0][0] = cosTheta;\n    rot[0][1] = -sinTheta;\n    rot[1][0] = sinTheta;\n    rot[1][1] = cosTheta;\n    \n    vec2 rotatedScrPt = scrPt * rot;\n    \n    float noiseVal = ComputeFBM(rotatedScrPt * 5.0 + 50.0 + u_time * 0.015625 * 1.5);\n    \n    rotatedScrPt += vec2(noiseVal) * 0.3;\n    \n    float centralFalloff = clamp(1.0 - length(scrPt.y + galaxyOffset), 0.0, 1.0);\n    float xDirFalloff = (cos(scrPt.x * 2.0) * 0.5 + 0.5);\n    \n    float centralFalloff_rot = 1.0 - length(rotatedScrPt.y + galaxyOffset);\n    float xDirFalloff_rot = (cos(rotatedScrPt.x * 2.0) * 0.5 + 0.5);\n    \n    // Falloff in y dir and x-dir fade\n    float lowFreqNoiseForFalloff = ComputeFBM(rotatedScrPt * 4.0 - u_time * 0.015625 * 1.5); // 1/64\n    //float lowFreqNoiseForFalloff_offset = ComputeFBM(rotatedScrPt * 1.5 + 0.005 * lowFreqNoiseForFalloff);\n    milkywayShape = clamp(pow(centralFalloff_rot, 3.0) - lowFreqNoiseForFalloff * 0.5, 0.0, 1.0) * xDirFalloff_rot;\n    \n    // Lighting\n    vec3 color;\n    \n    // desired brown color\n    //vec3 brown = vec3(0.35, 0.175, 0.15) * 17.0;\n    //vec3 mainColor = vec3(0.925, 1.0, 0.8) * 10.0;\n    //color = mix(brown, mainColor, pow(milkywayShape, 1.0)) * 2.0 * milkywayShape;\n    \n    // Cosine-based pallette: http://dev.thi.ng/gradients/\n    // there is also a famous IQ article on this and a less famous shader on my profile\n    color.r = palette(0.5, -1.081592653589793, 0.798407346410207, 0.0, pow(milkywayShape, 1.0));\n    color.g = palette(0.5, 0.658407346410207, 0.908407346410207, 0.268407346410207, pow(milkywayShape, 1.0));\n    color.b = palette(0.5, -0.201592653589793, 0.318407346410207, -0.001592653589793, pow(milkywayShape, 1.0));\n    \n    /* dont do this\n    color.r += 0.5 * palette(0.5, -0.481592653589793, 0.798407346410207, 0.0, pow(noiseVal, 1.0));\n    color.g += 0.5 * palette(0.5, 0.428407346410207, 0.908407346410207, 0.268407346410207, pow(noiseVal, 0.5));\n    color.b += 0.5 * palette(0.5, -0.001592653589793, 0.318407346410207, -0.001592653589793, pow(noiseVal, 1.0));\n    */\n    \n    // Experimented with removing color, worked out decently\n    float removeColor = (pow(milkywayShape, 10.0) + lowFreqNoiseForFalloff * 0.1) * 5.0;\n    color -= vec3(removeColor);\n    \n    // Add some blue to the background\n    vec3 backgroundCol = BackgroundColor(uv.xy * 0.125) * pow(centralFalloff, 0.5) * pow(xDirFalloff, 0.5);\n    vec3 blueish = vec3(0.2, 0.2, 0.4);\n    backgroundCol += blueish * (5.0 - milkywayShape) * pow(centralFalloff_rot, 2.0) * lowFreqNoiseForFalloff * pow(xDirFalloff, 0.75);\n    \n    vec3 whiteish = vec3(0.5, 1.0, 0.85);\n    backgroundCol += whiteish * 0.95 * pow(centralFalloff, 1.5) * lowFreqNoiseForFalloff * pow(xDirFalloff, 2.0);\n    \n    \n    finalColor = vec4(mix(backgroundCol, color, milkywayShape), 1);\n    \n    fragColor = finalColor;\n}`;\n\n\nconst game = new Engine({\n    width: 800,\n    height: 800,\n    displayMode: DisplayMode.FitScreen,\n    suppressPlayButton: true,\n    backgroundColor: Color.Black\n});\nconst imgNoise1 = new ImageSource(greynoise);\n\nconst loader = new Loader([\n    imgNoise1\n]);\n\nconst nebula = new Actor({\n    pos: game.screen.center,\n    width: 800,\n    height: 800,\n    color: Color.Transparent,\n    z: 1\n});\nnebula.graphics.material = game.graphicsContext.createMaterial({\n    fragmentSource: nebulaFrag,\n    images: {\n        u_noise: imgNoise1,\n    }\n});\n\ngame.add(nebula);\ngame.start(loader);\n\n"],"names":["greynoise","nebulaFrag","glsl","game","Engine","DisplayMode","Color","imgNoise1","ImageSource","loader","Loader","nebula","Actor"],"mappings":"sHAAA,MAAeA,EAAA,4CCITC,EAAaC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAmKbC,EAAO,IAAIC,EAAO,CACpB,MAAO,IACP,OAAQ,IACR,YAAaC,EAAY,UACzB,mBAAoB,GACpB,gBAAiBC,EAAM,KAC3B,CAAC,EACKC,EAAY,IAAIC,EAAYR,CAAS,EAErCS,EAAS,IAAIC,EAAO,CACtBH,CACJ,CAAC,EAEKI,EAAS,IAAIC,EAAM,CACrB,IAAKT,EAAK,OAAO,OACjB,MAAO,IACP,OAAQ,IACR,MAAOG,EAAM,YACb,EAAG,CACP,CAAC,EACDK,EAAO,SAAS,SAAWR,EAAK,gBAAgB,eAAe,CAC3D,eAAgBF,EAChB,OAAQ,CACJ,QAASM,CAAA,CAEjB,CAAC,EAEDJ,EAAK,IAAIQ,CAAM,EACfR,EAAK,MAAMM,CAAM"}